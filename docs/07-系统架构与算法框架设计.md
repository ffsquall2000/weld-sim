# 超声波焊接参数自动调整器 -- 系统架构与算法框架设计

> **文档版本**：V1.0
> **适用场景**：锂电池极耳超声波金属焊接
> **设计目标**：实现焊接参数的在线自适应调整，使过程能力 CPK >= 1.67

---

## 1. 系统总体架构

### 1.1 五层架构总览

```
┌──────────────────────────────────────────────────────────────────────┐
│                        Layer 5: 执行层 (Actuation Layer)              │
│  参数下发 → PLC/运动控制器 → 焊接设备执行                              │
├──────────────────────────────────────────────────────────────────────┤
│                        Layer 4: 决策层 (Decision Layer)               │
│  质量预测 │ 参数优化 │ 异常诊断 │ SPC 统计过程控制                      │
├──────────────────────────────────────────────────────────────────────┤
│                        Layer 3: 特征提取层 (Feature Extraction Layer) │
│  时域特征 │ 频域特征 │ 时频特征 │ 统计特征 │ 物理特征                    │
├──────────────────────────────────────────────────────────────────────┤
│                        Layer 2: 信号处理层 (Signal Processing Layer)  │
│  降噪滤波 │ 重采样对齐 │ 基线校正 │ 信号分段 │ 归一化                    │
├──────────────────────────────────────────────────────────────────────┤
│                        Layer 1: 数据采集层 (Data Acquisition Layer)   │
│  功率 P(t) │ 频率 f(t) │ 塌陷量 d(t) │ 力 F(t) │ 温度 │ 振幅反馈      │
└──────────────────────────────────────────────────────────────────────┘
```

### 1.2 各层详细设计

#### Layer 1: 数据采集层

| 组件 | 信号源 | 采样率 | 分辨率 | 接口协议 |
|------|--------|--------|--------|----------|
| 功率采集模块 | 发生器电压/电流传感器 | 10 kHz | 16-bit | EtherCAT / 模拟量 |
| 频率采集模块 | PLL 频率跟踪反馈 | 10 kHz | ±1 Hz | EtherCAT |
| 塌陷量采集模块 | 高精度位移传感器 (LVDT/光栅) | 5 kHz | 0.1 um | EtherCAT |
| 力采集模块 | 压电力传感器 / 伺服力反馈 | 2 kHz | ±1 N | EtherCAT / 模拟量 |
| 振幅反馈模块 | 换能器反馈端 | 10 kHz | 0.1 um | 模拟量 |
| 温度采集模块 | 焊头 / 环境热电偶 | 10 Hz | ±0.1 C | Modbus RTU |
| 设备状态模块 | PLC 状态寄存器 | 100 Hz | -- | EtherCAT / PROFINET |

**技术选型**：
- 采集硬件：Beckhoff EL3702 (模拟量高速采集) + EL5101 (编码器接口)
- 时钟同步：IEEE 1588 PTP 精密时间协议，各通道同步精度 < 1 us
- 数据缓冲：FPGA 环形缓冲区，确保单焊点数据完整采集

**输入**：传感器原始模拟/数字信号
**输出**：时间戳对齐的多通道原始采样数据矩阵 `D_raw in R^{C x N}`（C 为通道数，N 为采样点数）

---

#### Layer 2: 信号处理层

| 组件 | 功能 | 算法 | 延迟 |
|------|------|------|------|
| 数字滤波器 | 去除高频噪声与工频干扰 | 巴特沃斯低通 (截止 2kHz) + 50Hz 陷波 | < 0.5 ms |
| 重采样对齐 | 统一各通道采样率至 10kHz | 线性插值 / 样条插值 | < 0.1 ms |
| 基线校正 | 消除传感器零漂 | 焊前空载段均值减除 | < 0.1 ms |
| 信号分段 | 识别焊接起止点和阶段划分 | 功率阈值触发 + 塌陷速率变化点检测 | < 1 ms |
| 归一化 | 消除量纲差异 | Z-score 标准化 (基于滑动窗口统计量) | < 0.1 ms |

**关键设计**：
- 信号分段算法基于功率信号识别三个物理阶段：
  - Phase I（摩擦起始）：`P(t)` 超过空载功率的 3 倍时标记为 `t_start`
  - Phase II（稳态塑变）：`dP/dt` 由正转负的拐点标记为 `t_transition`
  - Phase III（焊接终止）：能量/时间/塌陷量达标或安全条件触发时标记为 `t_end`
- 采用零相位滤波（filtfilt）避免信号延迟失真

**输入**：原始采样数据矩阵 `D_raw`
**输出**：清洁、对齐、分段的信号矩阵 `D_clean in R^{C x N}`，附带阶段标记向量

---

#### Layer 3: 特征提取层

从处理后的信号中提取约 50 维特征向量，构成质量预测和决策的核心输入。

| 特征域 | 维数 | 具体特征 |
|--------|------|----------|
| 功率域 | 12 | P_mean, P_std, P_max, P_min, t_peak_P/T, P_slope_phase1, P_slope_phase2, E_total, E_phase1, E_phase2, P_kurtosis, P_skewness |
| 频率域 | 8 | f_mean, f_std, df_max, df_end, f_slope, df_dt_max, f_excursion_count, f_settling_time |
| 塌陷量域 | 8 | d_final, d_rate_mean, d_rate_max, d_onset_time, d_phase1, d_phase2, d_acceleration_max, d_jerk_max |
| 力域 | 4 | F_mean, F_std, F_overshoot, F_settling_time |
| 时频域 | 10 | wavelet_energy_band1~5, dominant_freq_shift, spectral_entropy, spectral_centroid, spectral_bandwidth, spectral_rolloff |
| 设定参数 | 4 | A_set, F_set, E_set, t_weld |
| 环境状态 | 4 | T_ambient, N_since_tip_change, Z_0_latest, batch_encoded |

**技术选型**：
- 时频分析：连续小波变换（CWT, Morlet 小波），窗口长度自适应焊接时间
- 统计特征：滚动计算，单焊点计算延迟 < 5 ms
- 特征存储：每焊点一条记录（~50 维 float64 + 元数据），约 500 bytes/焊点

**输入**：清洁信号矩阵 `D_clean` + 阶段标记
**输出**：特征向量 `X in R^{50}`

---

#### Layer 4: 决策层

决策层是系统的核心智能层，包含四个并行子模块：

```
                        ┌─────────────────┐
                        │  特征向量 X      │
                        └────┬───┬───┬────┘
                             │   │   │
              ┌──────────────┘   │   └──────────────┐
              v                  v                   v
   ┌──────────────────┐ ┌───────────────┐ ┌──────────────────┐
   │ 2.1 在线质量预测 │ │ 2.3 异常检测  │ │ 2.4 SPC 模块     │
   │     模型         │ │   与诊断      │ │                  │
   └────────┬─────────┘ └──────┬────────┘ └────────┬─────────┘
            │                  │                    │
            v                  v                    v
   ┌──────────────────────────────────────────────────────────┐
   │              2.2 自适应参数调整算法                         │
   │   贝叶斯优化 │ 磨损补偿 │ 批次自适应 │ 温度补偿            │
   └──────────────────────────┬───────────────────────────────┘
                              │
                              v
                    ┌───────────────────┐
                    │ 参数更新决策       │
                    │ u_new = [A, F, E] │
                    └───────────────────┘
```

**实时性分级**：

| 子模块 | 响应时间要求 | 运行频率 | 计算平台 |
|--------|-------------|---------|---------|
| 在线质量预测 | < 10 ms | 每焊点 | 边缘 GPU/CPU |
| 异常检测 | < 5 ms | 每焊点（安全相关实时） | 边缘 FPGA/CPU |
| SPC 统计控制 | < 100 ms | 每焊点 | 边缘 CPU |
| 参数优化 | < 500 ms | 每 N 焊点或触发式 | 边缘 GPU/CPU |

---

#### Layer 5: 执行层

| 组件 | 功能 | 接口 | 安全机制 |
|------|------|------|----------|
| 参数下发模块 | 将优化参数写入焊机控制器 | EtherCAT / OPC UA | 参数变化率限幅 (单次 <= ±5%) |
| 安全互锁模块 | 硬约束检查与紧急停机 | 硬件安全 PLC (SIL2) | 独立于软件决策的硬件保护 |
| 执行确认模块 | 读回实际执行参数验证一致性 | EtherCAT | 设定值-实际值偏差报警 |
| 日志记录模块 | 全量数据归档 | 本地 SSD + 网络上传 | 环形覆盖 + 关键事件永久保存 |

**输入**：优化后的参数向量 `u_new = [A_set, F_set, E_set, ...]`
**输出**：焊机控制器的参数寄存器更新 + 执行确认信号

**安全设计**：
- 参数变化率限幅：任何单次调整不超过当前值的 ±5%，防止算法异常导致的剧烈参数突变
- 参数范围硬约束：振幅 20-60 um, 压力 200-2000N, 能量 200-1500J
- 双通道安全架构：软件决策层 + 独立硬件安全 PLC，两者中任一触发保护即生效

---

## 2. 核心算法模块

### 2.1 在线质量预测模型

#### 2.1.1 问题定义

给定焊接过程的特征向量 `X in R^{50}`，预测焊接质量指标：

```
y_peel   = f_1(X) + epsilon_1    剥离力预测 (回归, 单位: N)
y_resist = f_2(X) + epsilon_2    接触电阻预测 (回归, 单位: mOhm)
y_class  = f_3(X)                合格/不合格分类 (二分类)
```

#### 2.1.2 输入特征设计（~50 维特征向量）

特征按物理意义和信息层级组织为三层：

```
Layer 1 -- 设定参数 (4维): 可控输入
  [A_set, F_set, E_set, t_weld]

Layer 2 -- 过程特征 (42维): 焊接过程的动态指纹
  功率域 (12维):
    P_mean          -- 平均功率，反映总体能量输入速率
    P_std           -- 功率波动，反映过程稳定性
    P_max           -- 峰值功率，与界面最大摩擦功率关联
    P_min           -- 最小功率，反映能量耦合下限
    t_peak_P_norm   -- 归一化峰值时刻 (t_peak/T)，<0.3 示退化过快，>0.8 示耦合不足
    P_slope_phase1  -- Phase I 功率上升斜率，反映氧化层破碎速率
    P_slope_phase2  -- Phase II 功率变化率，反映稳态塑变特性
    E_total         -- 总能量积分，最重要的单一特征 (重要度 ~0.28)
    E_phase1        -- Phase I 能量占比
    E_phase2        -- Phase II 能量占比
    P_kurtosis      -- 功率峰度，反映脉冲性异常
    P_skewness      -- 功率偏度，反映能量分布对称性

  频率域 (8维):
    f_mean          -- 平均频率偏移
    f_std           -- 频率波动标准差
    df_max          -- 最大频偏 |f(t) - f_0|
    df_end          -- 终态频偏 f(T) - f(0)
    f_slope         -- 频率线性趋势斜率
    df_dt_max       -- 最大频率变化率，突变指示箔材撕裂
    f_excursion_count  -- 频偏越限次数
    f_settling_time    -- 频率稳定时间

  塌陷量域 (8维):
    d_final         -- 最终塌陷量，与焊接强度强相关 (重要度 ~0.22)
    d_rate_mean     -- 平均塌陷速率
    d_rate_max      -- 最大塌陷速率
    d_onset_time    -- 塌陷开始时间
    d_phase1        -- Phase I 塌陷量
    d_phase2        -- Phase II 塌陷量
    d_accel_max     -- 最大塌陷加速度，>2.0 为过焊预警
    d_jerk_max      -- 最大塌陷跃度

  力域 (4维):
    F_mean          -- 平均焊接力
    F_std           -- 力波动
    F_overshoot     -- 力超调量
    F_settling_time -- 力稳定时间

  时频域 (10维):
    wt_energy_1~5   -- 5 个小波频带能量占比
    dominant_freq_shift -- 主频偏移
    spectral_entropy    -- 谱熵 (过程复杂度指标)
    spectral_centroid   -- 谱重心
    spectral_bandwidth  -- 谱带宽
    spectral_rolloff    -- 谱滚降频率

Layer 3 -- 环境状态 (4维): 缓变扰动
  T_ambient          -- 环境温度
  N_since_tip_change -- 自上次换焊头以来的焊接次数 (磨损代理变量)
  Z_0_latest         -- 最近一次空载阻抗测试值 (换能器状态)
  batch_encoded       -- 材料批次编码 (target encoding)
```

**特征工程要点**：
- 交互特征：`A_set x F_set`、`A_set x E_total` 在 Cu-Al 焊接中统计显著（p < 0.01），纳入模型
- 特征选择：使用 Boruta 算法或 SHAP 值进行特征重要性筛选，保留重要度 > 0.01 的特征
- 缺失值处理：传感器故障时使用物理约束填充（如 `E_total = integral(P(t)dt)` 可从功率信号重构）

#### 2.1.3 模型选型

**主模型：LightGBM + 物理约束后处理**

选型理由：
1. LightGBM 在结构化表格数据上性能优异，训练和推理速度快
2. 天然处理特征交互，无需手动构造交互项
3. 对缺失值和异常值鲁棒
4. 支持自定义损失函数，可嵌入物理约束

```python
# 模型配置
model_config = {
    "objective": "regression",         # 回归预测剥离力/接触电阻
    "metric": ["rmse", "mae"],
    "num_leaves": 63,                  # 控制复杂度
    "learning_rate": 0.05,
    "feature_fraction": 0.8,
    "bagging_fraction": 0.8,
    "bagging_freq": 5,
    "min_child_samples": 20,           # 防过拟合，适应小样本
    "reg_alpha": 0.1,                  # L1 正则
    "reg_lambda": 1.0,                 # L2 正则
    "n_estimators": 500,
    "early_stopping_rounds": 50,
}
```

**物理约束后处理层**：

```python
def apply_physical_constraints(y_pred, X):
    """
    对模型预测值施加物理约束，确保预测结果符合物理规律
    """
    # 约束1: 剥离力单调性 -- 在合理参数范围内，能量越大剥离力应越大
    # (通过 isotonic regression 校正违反单调性的预测)

    # 约束2: 接触电阻非负性
    y_pred["R_contact"] = np.maximum(y_pred["R_contact"], 0.001)

    # 约束3: 能量-强度物理上界 -- 剥离力不可能超过母材抗拉强度
    F_peel_upper = material_tensile_strength * weld_area
    y_pred["F_peel"] = np.minimum(y_pred["F_peel"], F_peel_upper)

    # 约束4: 过焊区间修正 -- 能量超过阈值后剥离力应下降
    overWeld_mask = X["E_total"] > E_overWeld_threshold
    if overWeld_mask.any():
        y_pred.loc[overWeld_mask, "F_peel"] *= decay_factor

    return y_pred
```

**辅助模型：NGBoost（用于不确定性量化）**

```
y_pred ~ N(mu(X), sigma(X))
```

NGBoost 输出预测均值 mu 和预测标准差 sigma，用于：
- 置信区间构造：`[mu - 2*sigma, mu + 2*sigma]` 覆盖约 95% 真实值
- 风险评估：当 `sigma` 异常增大时，指示当前工况偏离训练分布
- 决策支持：高不确定性时采用保守参数策略

#### 2.1.4 训练策略

**离线训练阶段**：

```
Step 1: 数据准备
  - 历史数据集: >= 5000 焊点（含拉剥力/电阻标签）
  - 数据分割: 时间序列分割（非随机），避免数据泄漏
    Train: 前 70% 时间段
    Valid: 中间 15% 时间段
    Test:  最后 15% 时间段

Step 2: 特征工程
  - 特征标准化参数保存（均值/标准差）
  - 特征重要性排序，剔除冗余特征

Step 3: 模型训练
  - 5-fold 时间序列交叉验证
  - 超参数搜索: Optuna 贝叶斯优化，200 trials
  - 集成策略: 5-fold 模型 Bagging

Step 4: 模型验证
  - Test 集评估: RMSE, MAE, R^2
  - 剥离力预测: RMSE < 3N, R^2 > 0.90
  - 接触电阻预测: RMSE < 0.01 mOhm, R^2 > 0.85
  - 分类指标: Precision > 0.95, Recall > 0.98 (不合格品召回优先)
```

**在线微调策略**：

```
触发条件（满足任一即触发微调）:
  (1) 累积新标签数据 >= 100 焊点
  (2) 预测残差滑动均值偏移 > 2 sigma
  (3) 材料批次变更
  (4) 焊头更换

微调方法:
  - 增量学习: 在原模型基础上追加训练轮次 (n_estimators += 50)
  - 学习率衰减: 微调阶段 lr = 0.01 (原始的 1/5)
  - 样本加权: 新数据权重 = 3.0, 旧数据权重 = 1.0
  - 回滚机制: 若微调后 validation 性能下降 > 5%, 自动回滚到上一版本
```

#### 2.1.5 不确定性量化

采用三层不确定性量化机制：

```
第一层 -- 模型不确定性 (Epistemic Uncertainty):
  方法: 5-fold Bagging 模型的预测方差
  sigma_model = std([y_pred_1, y_pred_2, ..., y_pred_5])
  含义: 训练数据不足区域，模型不确定性高

第二层 -- 数据不确定性 (Aleatoric Uncertainty):
  方法: NGBoost 输出的条件方差 sigma(X)
  含义: 相同输入下输出的固有随机性 (如材料微观不均匀性)

第三层 -- 分布外检测 (Out-of-Distribution Detection):
  方法: 基于训练集特征分布的 Mahalanobis 距离
  D_ood = sqrt((X - mu_train)^T * Sigma_train^{-1} * (X - mu_train))
  阈值: D_ood > chi2_inv(0.99, p) 触发 OOD 警告
  含义: 当前输入与训练数据分布差异过大，预测不可信
```

**不确定性驱动的决策策略**：

```
if D_ood > threshold_ood:
    action = "暂停自适应调整, 采用保守参数, 增加抽检频率"
elif sigma_total > threshold_high:
    action = "缩小参数调整步长, 增加抽检"
elif sigma_total < threshold_low:
    action = "正常自适应调整"
```

---

### 2.2 自适应参数调整算法

#### 2.2.1 总体框架

自适应参数调整采用分层架构，对应不同时间尺度的扰动：

```
┌─────────────────────────────────────────────────────────────┐
│  Level 3: 批次级自适应 (时间尺度: 数千焊点)                    │
│  - 材料批次变化自适应                                         │
│  - 模型参数重校                                              │
│  - 贝叶斯优化参数寻优                                        │
├─────────────────────────────────────────────────────────────┤
│  Level 2: 焊点间级调整 (时间尺度: 1~100 焊点)                 │
│  - 焊头磨损渐进补偿                                          │
│  - 环境温度补偿                                              │
│  - SPC 趋势修正                                             │
├─────────────────────────────────────────────────────────────┤
│  Level 1: 焊点内实时控制 (时间尺度: < 1 ms)                   │
│  - 频率 PLL 闭环                                            │
│  - 振幅闭环                                                 │
│  - 安全保护 (功率/塌陷量越限立即终止)                          │
│  [由焊机原生控制器实现, 本系统不干预]                           │
└─────────────────────────────────────────────────────────────┘
```

**本系统主要作用于 Level 2 和 Level 3**，Level 1 由焊机原生控制器保障。

#### 2.2.2 基于贝叶斯优化的参数寻优

**适用场景**：新产品导入、材料批次大幅变化、焊头更换后的参数重新寻优。

**优化问题形式化**：

```
min  J(u) = w_1 * [-F_peel_pred(u)] + w_2 * R_contact_pred(u) + w_3 * sigma_pred(u)
 u

subject to:
  硬约束 (Hard Constraints):
    A_set   in [A_min, A_max]          振幅范围: [20, 60] um
    F_set   in [F_min, F_max]          压力范围: [200, 2000] N
    E_set   in [E_min, E_max]          能量范围: [200, 1500] J
    d_pred  <= d_critical              塌陷量上限 (防穿孔)
    P_peak  <= P_max_safe              功率上限 (安全)

  软约束 (Soft Constraints, 以罚函数形式嵌入目标):
    CPK(F_peel) >= 1.67                过程能力约束
    cycle_time  <= CT_max              节拍约束
```

**目标函数权重设置**（体现安全优先原则）：

```
w_1 = 1.0    # 拉剥力 (越大越好, 取负号转为最小化)
w_2 = 5.0    # 接触电阻 (权重加大, 电气性能与安全直接相关)
w_3 = 2.0    # 预测不确定性 (鼓励选择模型确信度高的参数区间)

# 过焊惩罚项 (非线性, 靠近安全边界时急剧增大)
penalty_overWeld = lambda d: 100 * max(0, d - 0.8*d_critical)^2
```

**贝叶斯优化实现**：

```python
import numpy as np
from scipy.stats import norm

class BayesianWeldOptimizer:
    """
    基于高斯过程代理模型的贝叶斯参数优化器
    """
    def __init__(self, param_bounds, quality_model, safety_constraints):
        self.bounds = param_bounds           # 参数空间边界
        self.quality_model = quality_model   # 质量预测模型 (LightGBM)
        self.safety = safety_constraints     # 安全约束
        self.gp = GaussianProcessRegressor(
            kernel=Matern(nu=2.5),
            normalize_y=True,
            n_restarts_optimizer=10,
        )
        self.X_observed = []   # 已尝试的参数组合
        self.y_observed = []   # 对应的实际质量结果

    def acquisition_function(self, X_candidate, xi=0.01):
        """
        Expected Improvement with Constraints (EIC)
        在标准 EI 基础上乘以约束满足概率
        """
        mu, sigma = self.gp.predict(X_candidate, return_std=True)
        y_best = np.min(self.y_observed)

        # 标准 Expected Improvement
        Z = (y_best - mu - xi) / sigma
        EI = (y_best - mu - xi) * norm.cdf(Z) + sigma * norm.pdf(Z)

        # 约束满足概率
        P_safe = self._constraint_probability(X_candidate)

        return EI * P_safe

    def _constraint_probability(self, X_candidate):
        """
        计算约束满足概率:
        P(d_pred <= d_critical) * P(F_peel >= F_min)
        """
        # 使用质量预测模型的不确定性量化
        d_pred, d_sigma = self.quality_model.predict_collapse(X_candidate)
        F_pred, F_sigma = self.quality_model.predict_peel_force(X_candidate)

        P_collapse_safe = norm.cdf(
            (self.safety.d_critical - d_pred) / d_sigma
        )
        P_strength_ok = 1 - norm.cdf(
            (self.safety.F_min - F_pred) / F_sigma
        )

        return P_collapse_safe * P_strength_ok

    def suggest_next_params(self, n_candidates=1000):
        """
        建议下一组试验参数
        """
        # 随机生成候选点
        X_candidates = self._sample_candidates(n_candidates)

        # 计算采集函数值
        acq_values = self.acquisition_function(X_candidates)

        # 返回采集函数值最大的点
        best_idx = np.argmax(acq_values)
        return X_candidates[best_idx]

    def update(self, X_new, y_new):
        """
        用新观测数据更新代理模型
        """
        self.X_observed.append(X_new)
        self.y_observed.append(y_new)
        self.gp.fit(
            np.array(self.X_observed),
            np.array(self.y_observed)
        )
```

**收敛策略**：
- 初始探索阶段：前 10 次使用拉丁超立方采样 (LHS) 覆盖参数空间
- 优化阶段：EI 采集函数引导，exploration-exploitation 自动平衡
- 终止条件：连续 5 次 EI < 0.01 或达到最大迭代次数 (30 次)
- 安全约束：任何时刻均不允许超出硬约束边界

#### 2.2.3 焊头磨损补偿算法

焊头磨损是最主要的渐进性扰动源，典型寿命为铜焊 5-15 万次、铝焊 20-50 万次。

**磨损状态估计（软测量）**：

```
磨损指标 W(n) 由多信号趋势综合估计:

W(n) = alpha_1 * trend(P_mean, window=500)     # 平均功率趋势
     + alpha_2 * trend(E_per_weld, window=500)  # 单焊点能耗趋势
     + alpha_3 * trend(d_final, window=500)      # 塌陷量趋势
     + alpha_4 * (n / N_tip_life_expected)       # 焊接次数归一化

其中 trend() 为线性回归斜率的符号加权值
alpha 权重通过历史数据标定: [0.30, 0.25, 0.25, 0.20]
```

**补偿策略**：

```python
class TipWearCompensator:
    """
    焊头磨损在线补偿器
    """
    def __init__(self, baseline_params):
        self.baseline = baseline_params  # 新焊头时的标定参数
        self.W_history = []              # 磨损指标历史
        self.W_threshold_warn = 0.6      # 预警阈值
        self.W_threshold_critical = 0.85 # 必须更换阈值

    def compensate(self, current_params, W_est):
        """
        根据磨损状态补偿焊接参数
        """
        compensated = current_params.copy()

        if W_est > self.W_threshold_critical:
            # 磨损过度, 触发换头警报, 不再补偿
            raise TipReplacementAlert(
                f"磨损指标 W={W_est:.2f} 超过临界值, 需更换焊头"
            )

        if W_est > self.W_threshold_warn:
            # 磨损较重, 增大补偿量并提高抽检频率
            k_amplify = 1.5
        else:
            k_amplify = 1.0

        # 振幅补偿: 齿纹磨损导致耦合效率下降, 需提高振幅
        k_A = 0.08  # 补偿系数, 由标定实验确定
        compensated["A_set"] *= (1 + k_A * W_est * k_amplify)

        # 能量补偿: 磨损导致能量传递效率下降
        k_E = 0.05
        compensated["E_set"] *= (1 + k_E * W_est * k_amplify)

        # 压力补偿: 齿纹变浅需适当增加压力维持接触
        k_F = 0.03
        compensated["F_set"] *= (1 + k_F * W_est * k_amplify)

        # 安全限幅
        compensated = self._clamp_to_safe_range(compensated)

        return compensated

    def _clamp_to_safe_range(self, params):
        """参数限幅, 确保不超出安全范围"""
        params["A_set"] = np.clip(params["A_set"], 20, 60)
        params["F_set"] = np.clip(params["F_set"], 200, 2000)
        params["E_set"] = np.clip(params["E_set"], 200, 1500)
        return params
```

**空载特征定期检测**（每 M=500 次焊接执行一次）：

```
空载测试流程:
  1. 焊头抬起, 无工件状态
  2. 以标准参数短时激励 (50ms)
  3. 测量: 谐振频率 f_r, 空载阻抗 Z_0, 品质因子 Q
  4. 与基线值对比:
     Delta_f_r = f_r - f_r_baseline     频率偏移
     Delta_Z_0 = Z_0 / Z_0_baseline     阻抗比
     Delta_Q   = Q / Q_baseline          品质因子比
  5. 综合判定:
     if Delta_Z_0 > 1.3 or Delta_Q < 0.7:
         trigger_maintenance_alert("换能器/焊头异常")
```

#### 2.2.4 材料批次自适应算法

材料批次变化是最大的离散型扰动源，包括箔材厚度、硬度、氧化层厚度等变化。

**批次变化检测**：

```python
class BatchChangeDetector:
    """
    基于 MMD (Maximum Mean Discrepancy) 的材料批次变化检测
    """
    def __init__(self, reference_features, kernel_bandwidth=None):
        self.X_ref = reference_features   # 参考批次的特征分布
        self.sigma = kernel_bandwidth or self._median_heuristic()
        self.mmd_threshold = None         # 由 permutation test 确定

    def detect(self, X_new, window_size=50):
        """
        检测新一批焊点的特征分布是否与参考批次显著不同
        """
        # 取最近 window_size 个焊点的特征
        X_recent = X_new[-window_size:]

        # 计算 MMD^2
        mmd2 = self._compute_mmd2(self.X_ref, X_recent)

        # 与阈值比较
        is_shift = mmd2 > self.mmd_threshold
        shift_magnitude = mmd2 / self.mmd_threshold  # >1 表示显著

        return is_shift, shift_magnitude

    def _compute_mmd2(self, X, Y):
        """高斯核 MMD^2 估计"""
        K_XX = self._rbf_kernel(X, X)
        K_YY = self._rbf_kernel(Y, Y)
        K_XY = self._rbf_kernel(X, Y)
        n, m = len(X), len(Y)
        mmd2 = (K_XX.sum()/(n*(n-1)) + K_YY.sum()/(m*(m-1))
                - 2*K_XY.sum()/(n*m))
        return mmd2
```

**自适应调整流程**：

```
批次变化检测到 (MMD > threshold) 后:

Step 1: 小批量试焊 (N=10~20 焊点, 使用当前参数)
  -> 收集过程特征, 观察质量趋势

Step 2: 快速参数修正
  - 若质量指标在规格内但偏移: 基于质量预测模型梯度的参数微调
    delta_u = -lr * dJ/du  (lr = 0.1, 小步调整)
  - 若质量指标超规格: 触发贝叶斯优化重新寻优

Step 3: 在线模型微调
  - 将新批次数据加入训练集
  - 增量训练 quality_model
  - 更新特征标准化参数

Step 4: 渐进式参数切换
  - 参数不立即跳变, 而是在 N=20 焊点内线性插值过渡
  - u(n) = u_old * (1 - n/N) + u_new * (n/N), n = 1..N
  - 防止参数突变导致的质量波动
```

#### 2.2.5 环境温度补偿算法

```python
class TemperatureCompensator:
    """
    环境温度补偿器
    基于物理模型的温度-参数映射
    """
    def __init__(self, T_ref=23.0):
        self.T_ref = T_ref                # 参考温度 (标定温度)
        # 补偿系数 (由标定实验确定)
        self.alpha_E = -0.005  # 能量温度系数: 温度每升1C, 能量需减少0.5%
        self.alpha_F = -0.002  # 压力温度系数
        self.alpha_A = -0.001  # 振幅温度系数

    def compensate(self, params, T_current):
        """
        根据当前温度补偿焊接参数
        """
        dT = T_current - self.T_ref
        compensated = params.copy()

        # 温度升高时:
        #   - 材料屈服强度降低 -> 需减小能量防止过焊
        #   - 换能器谐振频率下降 (PLL 自动跟踪)
        #   - 焊头热膨胀影响对中
        compensated["E_set"] *= (1 + self.alpha_E * dT)
        compensated["F_set"] *= (1 + self.alpha_F * dT)
        compensated["A_set"] *= (1 + self.alpha_A * dT)

        # 焊头温度额外补偿 (连续焊接热积累)
        T_tip = self._estimate_tip_temperature(T_current)
        if T_tip > 60:  # 焊头温度过高, 额外降低能量
            tip_factor = 1 - 0.002 * (T_tip - 60)
            compensated["E_set"] *= max(tip_factor, 0.90)

        return compensated

    def _estimate_tip_temperature(self, T_ambient):
        """
        基于焊接频率和环境温度估算焊头温度
        简化热平衡模型: T_tip = T_amb + Q_gen/h_cool
        """
        # 实际实现中应使用焊头热电偶直接测量
        pass
```

#### 2.2.6 安全约束嵌入策略

**硬约束（不可违反，由独立安全系统保障）**：

```
硬约束清单:
  HC-1: A_set in [20, 60] um          振幅物理范围
  HC-2: F_set in [200, 2000] N        压力物理范围
  HC-3: E_set in [200, 1500] J        能量物理范围
  HC-4: P(t) <= P_critical            功率越限立即终止焊接
  HC-5: dd(t)/dt <= v_critical        塌陷加速度越限立即终止
  HC-6: |df(t)| <= df_critical        频偏越限立即终止
  HC-7: t <= t_max                    焊接时间上限

实现方式: 硬件安全 PLC (SIL2 等级), 独立于软件决策层
响应时间: < 1 ms
```

**软约束（允许小幅违反，通过罚函数引导优化）**：

```
软约束清单:
  SC-1: F_peel_pred >= 40 N           剥离力下限
  SC-2: R_contact_pred <= 0.1 mOhm    接触电阻上限
  SC-3: d_final_pred in [50, 200] um  塌陷量范围
  SC-4: CPK(F_peel) >= 1.67           过程能力
  SC-5: delta_u / u <= 5%             单次参数调整幅度

实现方式: 目标函数罚函数
  penalty = sum_i [ lambda_i * max(0, g_i(u))^2 ]
  lambda 取值: 安全相关约束 lambda = 100, 质量约束 lambda = 10
```

**安全优先级机制**：

```
优先级排序 (从高到低):
  P0 (紧急): 硬约束越限 -> 立即停机, 不经过决策层
  P1 (高):   过焊预警信号 -> 立即终止当前焊接, 降低下一焊点能量
  P2 (中):   质量预测不合格 -> 标记增检, 微调参数
  P3 (低):   SPC 趋势报警 -> 记录, 在下一批次调整窗口处理
```

---

### 2.3 异常检测与诊断模块

#### 2.3.1 实时异常检测

采用双模型并行架构，兼顾检测速度和检测能力：

**模型 A：Isolation Forest（快速粗筛）**

```python
class WeldAnomalyDetector:
    """
    基于 Isolation Forest 的实时异常检测器
    特点: 计算量小 (<1ms), 无需标签数据, 适合在线部署
    """
    def __init__(self, contamination=0.01):
        self.iforest = IsolationForest(
            n_estimators=200,
            max_samples=256,
            contamination=contamination,  # 预期异常比例 1%
            random_state=42,
        )
        self.feature_selector = [
            "E_total", "P_max", "d_final", "df_max",
            "P_kurtosis", "d_accel_max", "f_excursion_count",
            "spectral_entropy",
        ]  # 精选 8 维高判别力特征, 降低计算量

    def fit(self, X_train):
        """离线训练: 使用正常焊点数据"""
        X_selected = X_train[self.feature_selector]
        self.iforest.fit(X_selected)

    def detect(self, X_new):
        """
        在线检测: 返回异常分数和异常标记
        score < 0 为异常, 绝对值越大异常程度越高
        """
        X_selected = X_new[self.feature_selector]
        score = self.iforest.decision_function(X_selected)
        is_anomaly = self.iforest.predict(X_selected) == -1
        return is_anomaly, score
```

**模型 B：自编码器（深度异常检测）**

```python
class AutoEncoderAnomalyDetector:
    """
    基于自编码器的异常检测器
    特点: 能捕捉高维特征间的复杂非线性关系
    适用: 焊点间级检测 (延迟 <5ms)
    """
    def __init__(self, input_dim=50, encoding_dim=10):
        # 编码器: 50 -> 32 -> 16 -> 10
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 32),
            nn.ReLU(),
            nn.BatchNorm1d(32),
            nn.Linear(32, 16),
            nn.ReLU(),
            nn.Linear(16, encoding_dim),
        )
        # 解码器: 10 -> 16 -> 32 -> 50
        self.decoder = nn.Sequential(
            nn.Linear(encoding_dim, 16),
            nn.ReLU(),
            nn.BatchNorm1d(16),
            nn.Linear(16, 32),
            nn.ReLU(),
            nn.Linear(32, input_dim),
        )
        self.threshold = None  # 由验证集确定

    def detect(self, X_new):
        """
        异常检测: 重构误差超过阈值即为异常
        """
        X_tensor = torch.FloatTensor(X_new)
        X_reconstructed = self.decoder(self.encoder(X_tensor))
        reconstruction_error = torch.mean(
            (X_tensor - X_reconstructed) ** 2, dim=1
        )
        is_anomaly = reconstruction_error > self.threshold
        return is_anomaly, reconstruction_error
```

**双模型融合决策**：

```
异常判定逻辑:
  IF IsolationForest 判定异常 AND AutoEncoder 判定异常:
      -> 高置信度异常, 立即标记并触发诊断
  IF IsolationForest 判定异常 XOR AutoEncoder 判定异常:
      -> 可疑焊点, 标记增检, 继续监控
  IF 两者均正常:
      -> 正常焊点

异常分级:
  Level 1 (轻微): 异常分数在阈值附近 -> 记录, 不干预
  Level 2 (明显): 异常分数超过 2x 阈值 -> 标记增检, 参数微调
  Level 3 (严重): 异常分数超过 5x 阈值 -> 停机诊断
```

#### 2.3.2 根因分析

基于特征重要性的分层诊断树：

```
                           [异常检测触发]
                                |
                    ┌───────────┼───────────┐
                    v           v           v
              [功率域异常]  [频率域异常]  [塌陷量域异常]
                    |           |           |
              ┌─────┴─────┐    |     ┌─────┴─────┐
              v           v    v     v           v
         [P 偏高]    [P 偏低]  |  [d 偏大]    [d 偏小]
              |           |    |     |           |
              v           v    v     v           v
```

```python
class RootCauseAnalyzer:
    """
    基于特征偏移方向和SHAP值的根因分析器
    """
    # 诊断规则库
    DIAGNOSIS_RULES = {
        "P_max_high + d_accel_high": {
            "root_cause": "过焊风险",
            "probable_reasons": [
                "能量设定偏高",
                "材料批次偏软 (退火态)",
                "焊头温度过高导致材料提前软化",
            ],
            "recommended_actions": [
                "降低能量设定 3-5%",
                "检查材料批次硬度报告",
                "检查焊头冷却系统",
            ],
            "severity": "HIGH",
        },
        "E_total_high + d_final_low": {
            "root_cause": "能量耦合效率下降",
            "probable_reasons": [
                "焊头磨损严重",
                "焊头-工件对中偏移",
                "砧座齿纹磨损",
            ],
            "recommended_actions": [
                "检查焊头磨损状态",
                "校准焊头对中",
                "检查砧座状态",
            ],
            "severity": "MEDIUM",
        },
        "f_excursion_high + P_kurtosis_high": {
            "root_cause": "焊接过程不稳定",
            "probable_reasons": [
                "极耳对齐不良",
                "层间异物/氧化严重",
                "气源压力波动",
            ],
            "recommended_actions": [
                "检查极耳定位夹具",
                "检查来料表面状态",
                "检查气源压力稳定性",
            ],
            "severity": "MEDIUM",
        },
        "df_dt_max_extreme": {
            "root_cause": "箔材撕裂或焊头打滑",
            "probable_reasons": [
                "振幅过大导致表层撕裂",
                "焊头齿纹严重磨损导致打滑",
                "极耳层数异常 (缺层或多层)",
            ],
            "recommended_actions": [
                "立即停机检查焊点外观",
                "检查焊头齿纹状态",
                "检查来料极耳层数",
            ],
            "severity": "HIGH",
        },
        "Z_0_drift + Q_factor_decline": {
            "root_cause": "换能器/声学系统退化",
            "probable_reasons": [
                "压电陶瓷老化或预紧力松弛",
                "变幅杆疲劳裂纹",
                "焊头安装螺栓松动",
            ],
            "recommended_actions": [
                "安排换能器性能检测",
                "变幅杆探伤检查",
                "检查焊头安装扭矩",
            ],
            "severity": "HIGH",
        },
    }

    def analyze(self, X_anomaly, X_normal_baseline, shap_explainer):
        """
        对异常焊点进行根因分析
        """
        # Step 1: 计算各特征的偏移方向和幅度
        feature_deviations = {}
        for feat in X_anomaly.index:
            z_score = (
                (X_anomaly[feat] - X_normal_baseline[feat].mean())
                / X_normal_baseline[feat].std()
            )
            feature_deviations[feat] = z_score

        # Step 2: 计算 SHAP 值, 确定哪些特征对异常判定贡献最大
        shap_values = shap_explainer(X_anomaly)
        top_features = sorted(
            zip(shap_values, X_anomaly.index),
            key=lambda x: abs(x[0]),
            reverse=True,
        )[:5]

        # Step 3: 匹配诊断规则
        diagnosis = self._match_rules(feature_deviations)

        return {
            "top_deviating_features": feature_deviations,
            "shap_top_features": top_features,
            "diagnosis": diagnosis,
        }
```

#### 2.3.3 预测性维护

**焊头寿命预测**：

```python
class TipLifePredictor:
    """
    焊头剩余寿命预测 (Remaining Useful Life, RUL)
    基于退化趋势外推 + 生存分析
    """
    def __init__(self):
        # Weibull 分布参数 (由历史焊头寿命数据拟合)
        self.shape_param = None  # beta (形状参数)
        self.scale_param = None  # eta (尺度参数)
        self.degradation_model = None  # 退化趋势模型

    def predict_rul(self, W_history, current_n):
        """
        基于当前磨损轨迹预测剩余寿命
        """
        # 方法1: 退化趋势外推
        # 拟合磨损曲线 W(n) = a*n^b + c
        from scipy.optimize import curve_fit
        n_array = np.arange(len(W_history))
        popt, _ = curve_fit(
            lambda n, a, b, c: a * n**b + c,
            n_array, W_history,
            p0=[1e-5, 1.5, 0.01], maxfev=5000,
        )
        # 外推到 W = W_critical
        # 求解 a*n^b + c = W_critical 得到 n_failure
        n_failure = ((self.W_critical - popt[2]) / popt[0]) ** (1/popt[1])
        rul_trend = max(0, n_failure - current_n)

        # 方法2: Weibull 条件可靠度
        # R(t+delta|t) = R(t+delta)/R(t)
        R_current = np.exp(-(current_n/self.scale_param)**self.shape_param)
        # 找到 R(t+rul)/R(t) = 0.1 (90%概率失效) 的 rul
        rul_weibull = self._solve_conditional_rul(current_n, target_R=0.1)

        # 综合两种方法: 取保守值 (较小的 RUL)
        rul = min(rul_trend, rul_weibull)

        # 置信区间
        rul_lower = rul * 0.7   # 保守估计
        rul_upper = rul * 1.3   # 乐观估计

        return {
            "rul_point_estimate": int(rul),
            "rul_lower_bound": int(rul_lower),
            "rul_upper_bound": int(rul_upper),
            "replacement_recommended_at": current_n + int(rul_lower),
            "must_replace_at": current_n + int(rul),
        }
```

**换能器状态评估**：

```
换能器健康指标 (每 M=500 焊接周期评估):

  H_transducer = w1*H_freq + w2*H_impedance + w3*H_Q + w4*H_efficiency

  其中:
    H_freq       = 1 - |f_r - f_r_baseline| / f_r_tolerance
    H_impedance  = 1 - |Z_0 - Z_0_baseline| / Z_0_tolerance
    H_Q          = Q_current / Q_baseline
    H_efficiency = eta_current / eta_baseline

  健康等级:
    H > 0.8    : 良好 (绿色)
    0.6 < H <= 0.8 : 注意 (黄色), 安排下一次计划停机检修
    0.4 < H <= 0.6 : 警告 (橙色), 尽快安排检修
    H <= 0.4   : 危险 (红色), 立即停机更换
```

---

### 2.4 SPC 统计过程控制模块

#### 2.4.1 控制图自动生成

```python
class SPCControlChart:
    """
    SPC 控制图管理器
    支持 X-bar-R, X-bar-S, I-MR, EWMA, CUSUM 控制图
    """
    def __init__(self):
        self.charts = {}

    def setup_charts(self):
        """初始化所有监控变量的控制图"""
        self.charts = {
            # 过程变量控制图
            "E_total": XbarRChart(
                name="焊接能量",
                subgroup_size=5,
                unit="J",
            ),
            "d_final": XbarSChart(
                name="最终塌陷量",
                subgroup_size=5,
                unit="um",
            ),
            "P_max": EWMAChart(
                name="峰值功率",
                lambda_=0.2,
                unit="W",
            ),
            # 质量指标控制图
            "F_peel": XbarRChart(
                name="剥离力",
                subgroup_size=5,
                unit="N",
            ),
            "R_contact": IMRChart(
                name="接触电阻",
                unit="mOhm",
            ),
            # 综合质量指数
            "QCI": CUSUMChart(
                name="综合质量指数",
                k=0.5,    # CUSUM 参考值 (0.5 sigma)
                h=5.0,    # CUSUM 决策限 (5 sigma)
            ),
            # 多变量控制图
            "multivariate": HotellingT2Chart(
                name="多变量综合监控",
                variables=["E_total", "d_final", "P_max", "df_max"],
                alpha=0.01,
            ),
        }

    def update(self, data_point):
        """每焊点更新所有控制图"""
        alarms = []
        for name, chart in self.charts.items():
            if name == "multivariate":
                result = chart.update(data_point)
            else:
                result = chart.update(data_point[name])

            if result["alarm"]:
                alarms.append({
                    "chart": name,
                    "rule_violated": result["rule"],
                    "value": result["value"],
                    "severity": result["severity"],
                })
        return alarms
```

#### 2.4.2 Western Electric 规则 + CUSUM + EWMA

**Western Electric 规则（8 条）**：

```
Rule 1: 单点超出 3-sigma 控制限
        -> 严重, 立即调查
Rule 2: 连续 9 点在中心线同一侧
        -> 过程均值漂移
Rule 3: 连续 6 点单调递增或递减
        -> 过程存在趋势
Rule 4: 连续 14 点交替上下波动
        -> 过程存在周期性干扰
Rule 5: 连续 3 点中有 2 点超出 2-sigma
        -> 过程变异增大
Rule 6: 连续 5 点中有 4 点超出 1-sigma
        -> 过程偏移
Rule 7: 连续 15 点在 1-sigma 以内
        -> 控制限可能过宽, 或数据分层
Rule 8: 连续 8 点超出 1-sigma (两侧均可)
        -> 混合分布
```

```python
class WesternElectricRules:
    """Western Electric 规则检测器"""

    def check_all_rules(self, data, mean, sigma):
        violations = []
        z_scores = (np.array(data) - mean) / sigma

        # Rule 1: 单点超 3-sigma
        if abs(z_scores[-1]) > 3:
            violations.append({
                "rule": 1,
                "description": "单点超出3-sigma控制限",
                "severity": "HIGH",
            })

        # Rule 2: 连续9点同侧
        if len(z_scores) >= 9:
            last_9 = z_scores[-9:]
            if all(x > 0 for x in last_9) or all(x < 0 for x in last_9):
                violations.append({
                    "rule": 2,
                    "description": "连续9点在中心线同一侧 (均值漂移)",
                    "severity": "MEDIUM",
                })

        # Rule 3: 连续6点单调趋势
        if len(z_scores) >= 6:
            last_6 = z_scores[-6:]
            diffs = np.diff(last_6)
            if all(d > 0 for d in diffs) or all(d < 0 for d in diffs):
                violations.append({
                    "rule": 3,
                    "description": "连续6点单调趋势",
                    "severity": "MEDIUM",
                })

        # Rule 5: 3点中2点超2-sigma
        if len(z_scores) >= 3:
            last_3 = z_scores[-3:]
            if sum(abs(x) > 2 for x in last_3) >= 2:
                violations.append({
                    "rule": 5,
                    "description": "3点中2点超出2-sigma",
                    "severity": "MEDIUM",
                })

        return violations
```

**CUSUM 控制图**：

```python
class CUSUMChart:
    """
    累积和控制图 -- 对 0.5~1.5 sigma 的持续小漂移更敏感
    """
    def __init__(self, name, k=0.5, h=5.0):
        self.name = name
        self.k = k          # 参考值 (通常取 delta/2, delta 为要检测的漂移量)
        self.h = h          # 决策限 (通常取 4~5)
        self.C_plus = 0     # 上侧累积和
        self.C_minus = 0    # 下侧累积和
        self.mean = None
        self.sigma = None

    def update(self, value):
        z = (value - self.mean) / self.sigma
        # 上侧 CUSUM: 检测均值上升
        self.C_plus = max(0, self.C_plus + z - self.k)
        # 下侧 CUSUM: 检测均值下降
        self.C_minus = max(0, self.C_minus - z - self.k)

        alarm = False
        direction = None
        if self.C_plus > self.h:
            alarm = True
            direction = "上升"
            self.C_plus = 0  # 重置
        if self.C_minus > self.h:
            alarm = True
            direction = "下降"
            self.C_minus = 0  # 重置

        return {
            "alarm": alarm,
            "rule": f"CUSUM {direction}漂移" if alarm else None,
            "value": value,
            "C_plus": self.C_plus,
            "C_minus": self.C_minus,
            "severity": "MEDIUM" if alarm else None,
        }
```

**EWMA 控制图**：

```python
class EWMAChart:
    """
    指数加权移动平均控制图
    lambda=0.1~0.3 适合检测小幅均值漂移
    """
    def __init__(self, name, lambda_=0.2, L=3.0, unit=""):
        self.name = name
        self.lambda_ = lambda_    # 平滑常数
        self.L = L                # 控制限系数
        self.unit = unit
        self.Z = None             # EWMA 统计量
        self.mean = None
        self.sigma = None
        self.n = 0

    def update(self, value):
        self.n += 1
        if self.Z is None:
            self.Z = self.mean

        # EWMA 递推
        self.Z = self.lambda_ * value + (1 - self.lambda_) * self.Z

        # 时变控制限 (考虑起始阶段方差较大)
        factor = self.lambda_ / (2 - self.lambda_)
        factor *= (1 - (1 - self.lambda_)**(2 * self.n))
        sigma_Z = self.sigma * np.sqrt(factor)

        UCL = self.mean + self.L * sigma_Z
        LCL = self.mean - self.L * sigma_Z

        alarm = self.Z > UCL or self.Z < LCL

        return {
            "alarm": alarm,
            "rule": "EWMA越限" if alarm else None,
            "value": value,
            "EWMA": self.Z,
            "UCL": UCL,
            "LCL": LCL,
            "severity": "MEDIUM" if alarm else None,
        }
```

#### 2.4.3 CPK/PPK 实时计算

```python
class ProcessCapabilityCalculator:
    """
    过程能力指数实时计算器
    支持滑动窗口计算, 实时监控过程能力变化趋势
    """
    def __init__(self, window_size=100):
        self.window_size = window_size
        self.data_buffer = deque(maxlen=window_size)

    def update(self, value):
        self.data_buffer.append(value)

    def calculate_cpk(self, LSL=None, USL=None):
        """
        计算 CPK (过程能力指数)
        CPK = min(CPU, CPL)
        CPU = (USL - mean) / (3 * sigma_within)
        CPL = (mean - LSL) / (3 * sigma_within)
        """
        if len(self.data_buffer) < 30:
            return None  # 数据不足, 不计算

        data = np.array(self.data_buffer)
        mean = np.mean(data)
        sigma = np.std(data, ddof=1)

        if sigma == 0:
            return float('inf')

        cpk_values = []
        if USL is not None:
            cpu = (USL - mean) / (3 * sigma)
            cpk_values.append(cpu)
        if LSL is not None:
            cpl = (mean - LSL) / (3 * sigma)
            cpk_values.append(cpl)

        if not cpk_values:
            return None

        cpk = min(cpk_values)
        return cpk

    def calculate_ppk(self, LSL=None, USL=None):
        """
        计算 PPK (过程性能指数)
        使用全部历史数据的总标准差
        """
        # 类似 CPK 但使用总体标准差 (包含组间变异)
        pass

    def get_capability_report(self):
        """
        生成过程能力报告
        """
        data = np.array(self.data_buffer)
        return {
            "sample_size": len(data),
            "mean": np.mean(data),
            "std": np.std(data, ddof=1),
            "min": np.min(data),
            "max": np.max(data),
            "cpk_peel_force": self.calculate_cpk(LSL=40.0),
            "cpk_resistance": self.calculate_cpk(USL=0.1),
            "cpk_collapse": self.calculate_cpk(LSL=50.0, USL=200.0),
        }
```

**CPK 监控目标**：

| 质量指标 | LSL | USL | CPK 目标 | CPK 报警线 | PPK 目标 |
|---------|-----|-----|---------|-----------|---------|
| 剥离力 (N) | 40 | -- | >= 1.67 | < 1.33 | >= 1.33 |
| 接触电阻 (mOhm) | -- | 0.1 | >= 1.67 | < 1.33 | >= 1.33 |
| 塌陷量 (um) | 50 | 200 | >= 1.33 | < 1.00 | >= 1.00 |
| 焊印覆盖率 (%) | 85 | -- | >= 1.33 | < 1.00 | >= 1.00 |

#### 2.4.4 趋势预警与自动报警

```
报警分层体系:

Level 0 (正常/绿色):
  条件: 所有控制图在控, CPK >= 1.67
  动作: 正常生产, 标准抽检频率 (每 50 焊点抽检 1 个)

Level 1 (注意/蓝色):
  条件: 任一信号在 2-sigma ~ 3-sigma 内, 或 1.33 <= CPK < 1.67
  动作: 记录事件, 抽检频率提升至每 20 焊点 1 个

Level 2 (警告/黄色):
  条件: 触发 Western Electric Rule 2/3/5/6, 或 1.00 <= CPK < 1.33
  动作: 触发参数微调, 抽检频率提升至每 10 焊点 1 个, 通知工艺工程师

Level 3 (报警/橙色):
  条件: 触发 Western Electric Rule 1, 或 CUSUM/EWMA 越限, 或 CPK < 1.00
  动作: 停止自适应调整, 标记全检, 通知设备主管

Level 4 (紧急/红色):
  条件: 关键安全参数越限 (过焊信号, 频率失锁, 功率失控)
  动作: 立即停机, 触发安全联锁, 通知产线负责人
```

**自动报警通知矩阵**：

| 报警级别 | HMI 弹窗 | 声光报警 | MES 推送 | 短信/邮件 | 停线 |
|---------|---------|---------|---------|----------|------|
| Level 0 | -- | -- | 记录 | -- | -- |
| Level 1 | 信息 | -- | 记录 | -- | -- |
| Level 2 | 警告 | 黄灯 | 事件 | 邮件 | -- |
| Level 3 | 报警 | 黄灯闪 | 事件+工单 | 短信+邮件 | 可选 |
| Level 4 | 紧急 | 红灯+蜂鸣 | 紧急工单 | 短信+电话 | 强制 |

---

## 3. 数据流与接口设计

### 3.1 端到端数据流

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                            单焊点数据生命周期                                     │
│                                                                                 │
│  焊接触发      信号采集        信号处理        特征提取      决策         执行       │
│  ────┬─── ────┬──── ────┬──── ────┬──── ────┬──── ────┬────                     │
│      │        │         │         │         │         │                          │
│  t=0 │  0~Tms │  +2ms   │  +5ms   │ +10ms   │ +15ms   │                         │
│      │        │         │         │         │         │                          │
│      v        v         v         v         v         v                          │
│  PLC触发  传感器      滤波降噪   50维向量   预测+SPC   参数下发                     │
│  信号     原始数据    分段对齐   提取       优化判定   至下一焊点                    │
│           (~5KB)     (~5KB)    (~400B)    (~100B)   (~50B)                       │
│                                                                                 │
│  ────────────── 焊接周期内 (200~500ms) ────────────────── 焊点间隙 (~500ms) ──── │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 数据流量估算

```
单焊点数据量:
  原始信号:  6通道 x 10kHz x 500ms x 2bytes = 60 KB
  处理后信号: 6通道 x 10kHz x 500ms x 4bytes = 120 KB (float32)
  特征向量:  50维 x 8bytes = 400 bytes
  元数据:    时间戳 + 设备ID + 批次ID + 参数设定 ~ 500 bytes
  总计:      ~180 KB / 焊点

产线数据流量 (单工位, CT=1.5s):
  原始数据:   60 KB x 2400 焊点/小时 = 144 MB/小时
  归档数据:   180 KB x 2400 = 432 MB/小时
  日数据量:   432 MB x 20 小时 = 8.6 GB/天/工位

多工位产线 (10 工位):
  日数据量:   86 GB/天
  月数据量:   ~2.5 TB/月
```

### 3.3 关键接口定义

#### 3.3.1 数据采集层 -> 信号处理层

```
接口名称: IF-01 原始信号接口
协议: 共享内存 (Shared Memory) / Ring Buffer
数据格式:
  {
    "weld_id": "W20260225-001-0001",     // 焊点唯一ID
    "timestamp_start": 1740000000.000,    // 焊接开始时间戳 (PTP同步)
    "sample_rate_hz": 10000,              // 采样率
    "channels": {
      "power_W":     [float32 array],     // 功率信号, 单位 W
      "frequency_Hz": [float32 array],    // 频率信号, 单位 Hz
      "collapse_um":  [float32 array],    // 塌陷量, 单位 um
      "force_N":      [float32 array],    // 力信号, 单位 N
      "amplitude_um": [float32 array],    // 振幅反馈, 单位 um
      "voltage_V":    [float32 array],    // 电压信号, 单位 V
    },
    "settings": {
      "A_set_um": 35.0,
      "F_set_N": 800.0,
      "E_set_J": 500.0,
      "trigger_mode": "energy",
    },
    "environment": {
      "T_ambient_C": 23.5,
      "T_tip_C": 45.2,
      "humidity_pct": 28.0,
    }
  }
延迟要求: < 1 ms (焊接完成后信号缓冲区就绪)
```

#### 3.3.2 特征提取层 -> 决策层

```
接口名称: IF-02 特征向量接口
协议: 内存消息队列 (ZeroMQ inproc)
数据格式:
  {
    "weld_id": "W20260225-001-0001",
    "features": {
      "power": {"P_mean": 1200.5, "P_std": 85.3, ...},
      "frequency": {"f_mean": 19998.5, "df_max": 125.0, ...},
      "collapse": {"d_final": 120.5, "d_rate_max": 0.85, ...},
      "force": {"F_mean": 802.0, ...},
      "spectral": {"spectral_entropy": 3.45, ...},
      "settings": {"A_set": 35.0, ...},
      "environment": {"T_ambient": 23.5, ...},
    },
    "feature_vector": [float64 array, dim=50],  // 标准化后的特征向量
    "phase_markers": {
      "t_start_ms": 0.0,
      "t_phase1_end_ms": 45.2,
      "t_phase2_end_ms": 285.0,
      "t_end_ms": 310.5,
    },
    "data_quality": {
      "missing_channels": [],
      "clipped_channels": [],
      "noise_level": "normal",
    }
  }
延迟要求: < 10 ms (特征提取完成)
```

#### 3.3.3 决策层 -> 执行层

```
接口名称: IF-03 参数调整指令接口
协议: OPC UA / EtherCAT
数据格式:
  {
    "command_id": "CMD-20260225-001-0001",
    "command_type": "PARAM_UPDATE",       // PARAM_UPDATE | EMERGENCY_STOP | NO_ACTION
    "target_weld_id": "next",             // 应用于下一焊点
    "parameters": {
      "A_set_um": 35.5,                   // 振幅调整后值
      "F_set_N": 810.0,                   // 压力调整后值
      "E_set_J": 505.0,                   // 能量调整后值
    },
    "change_rationale": {
      "trigger": "tip_wear_compensation",
      "wear_index": 0.35,
      "delta_pct": {"A": "+1.4%", "F": "+1.2%", "E": "+1.0%"},
    },
    "safety_check": {
      "within_hard_constraints": true,
      "max_single_step_pct": 2.5,
      "quality_prediction": {"F_peel": 52.3, "R_contact": 0.035},
    }
  }
延迟要求: < 500 ms (在下一焊接周期开始前完成)
```

#### 3.3.4 与 MES/SCADA 的上行接口

```
接口名称: IF-04 MES 数据上报接口
协议: MQTT / OPC UA / RESTful API
上报频率: 每焊点上报摘要, 异常时实时推送
数据格式:
  {
    "weld_id": "W20260225-001-0001",
    "timestamp": "2026-02-25T10:30:45.123Z",
    "equipment_id": "UW-LINE1-ST01",
    "product_id": "CELL-4680-V2",
    "batch_id": "BAT-20260225-A",
    "result": "PASS",                     // PASS | FAIL | SUSPECT
    "quality_metrics": {
      "F_peel_pred_N": 52.3,
      "R_contact_pred_mOhm": 0.035,
      "d_final_um": 120.5,
      "E_total_J": 505.2,
    },
    "spc_status": {
      "alarm_level": 0,
      "cpk_F_peel": 1.85,
      "cpk_R_contact": 2.10,
    },
    "parameter_adjustments": {
      "adjusted": true,
      "reason": "tip_wear_compensation",
    }
  }
```

### 3.4 实时性要求汇总

| 模块/接口 | 延迟要求 | 频率 | 关键性 | 实现方式 |
|-----------|---------|------|--------|---------|
| 硬件安全保护 | < 1 ms | 连续 | 安全关键 | FPGA / 安全PLC |
| 原始信号采集 | < 0.1 ms | 10 kHz | 高 | EtherCAT + FPGA缓冲 |
| 信号处理 | < 2 ms | 每焊点 | 高 | 边缘CPU实时线程 |
| 特征提取 | < 5 ms | 每焊点 | 高 | 边缘CPU实时线程 |
| 质量预测 | < 10 ms | 每焊点 | 高 | 边缘GPU/CPU |
| 异常检测 | < 5 ms | 每焊点 | 高 | 边缘CPU |
| SPC 更新 | < 100 ms | 每焊点 | 中 | 边缘CPU |
| 参数优化 | < 500 ms | 每N焊点 | 中 | 边缘GPU/CPU |
| MES 上报 | < 1 s | 每焊点 | 低 | 网络异步 |
| 模型训练/更新 | 分钟~小时 | 触发式 | 低 | 云端GPU |
| 报表/可视化 | < 5 s | 按需 | 低 | 云端/Web |

---

## 4. 部署架构

### 4.1 边缘-云端协同架构

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                              云端 (Cloud)                                    │
│                                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │
│  │ 模型训练中心  │  │ 数据湖       │  │ BI 分析平台  │  │ 模型版本管理  │    │
│  │ GPU集群      │  │ (S3/HDFS)   │  │ (Grafana)   │  │ (MLflow)     │    │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘    │
│         │                 │                 │                 │              │
│         └────────┬────────┴────────┬────────┴────────┬────────┘              │
│                  │                 │                 │                        │
│  ════════════════╪═════════════════╪═════════════════╪══════ 专线/VPN ═══════ │
└──────────────────┼─────────────────┼─────────────────┼───────────────────────┘
                   │                 │                 │
┌──────────────────┼─────────────────┼─────────────────┼───────────────────────┐
│                  │       工厂边缘层 (Edge)            │                       │
│                  │                 │                 │                        │
│  ┌───────────────v─────────────────v─────────────────v───────────────┐       │
│  │                    边缘服务器 (Edge Server)                        │       │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐            │       │
│  │  │ 推理引擎 │ │ SPC引擎  │ │ 优化引擎 │ │ 数据管道 │            │       │
│  │  │(ONNX RT) │ │          │ │(BO/补偿) │ │(Kafka)   │            │       │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘            │       │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────────────────┐            │       │
│  │  │ 时序DB   │ │ 模型缓存 │ │ 本地归档 (SSD RAID)  │            │       │
│  │  │(InfluxDB)│ │          │ │                      │            │       │
│  │  └──────────┘ └──────────┘ └──────────────────────┘            │       │
│  └──────────────────────┬────────────────────────────────────────────┘       │
│                         │ EtherCAT / PROFINET                                │
│  ┌──────────────────────v────────────────────────────────────────────┐       │
│  │                  设备控制层 (Field Level)                           │       │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐            │       │
│  │  │ 焊接PLC  │ │ 采集卡   │ │ 安全PLC  │ │ HMI      │            │       │
│  │  │ (主控)   │ │ (DAQ)    │ │ (SIL2)   │ │ (触摸屏) │            │       │
│  │  └──────────┘ └──────────┘ └──────────┘ └──────────┘            │       │
│  └───────────────────────────────────────────────────────────────────┘       │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 边缘服务器配置

```
推荐配置 (单工位):
  CPU:     Intel Core i7-13700 / AMD Ryzen 7 7700 (8核16线程)
  GPU:     NVIDIA T400 / RTX A2000 (用于推理加速, 可选)
  内存:    32 GB DDR5
  存储:    500 GB NVMe SSD (本地缓存) + 2 TB SATA SSD (归档)
  网络:    双千兆以太网 (一路 EtherCAT, 一路 IT 网络)
  OS:      Ubuntu 22.04 LTS + RT-PREEMPT 实时内核
  容器:    Docker + K3s (轻量 Kubernetes)

推荐配置 (10 工位共享):
  CPU:     Intel Xeon W-2400 / AMD EPYC 4000 系列
  GPU:     NVIDIA A30 (推理 + 轻量训练)
  内存:    128 GB DDR5 ECC
  存储:    2 TB NVMe SSD + 10 TB HDD RAID
  网络:    10GbE + EtherCAT 交换机
```

### 4.3 与焊接设备的集成方式

```
集成方案选型 (按优先级):

方案 A: EtherCAT 直连 (推荐)
  适用: Branson, Herrmann, Schunk 等主流焊机
  优势: 实时性最佳 (<1ms), 标准工业协议
  实现: 边缘服务器安装 EtherCAT Master 卡 (如 Beckhoff)
        焊机作为 EtherCAT Slave, 暴露参数寄存器
  数据: 过程变量实时读取 + 参数实时写入

方案 B: OPC UA 集成
  适用: 支持 OPC UA 的现代焊机
  优势: 跨平台, 语义化, 安全认证
  实现: 焊机内置 OPC UA Server
        边缘服务器作为 OPC UA Client 订阅/写入
  延迟: ~10-50 ms (可接受, 用于焊点间级参数调整)

方案 C: PLC 中转
  适用: 旧型号焊机, 仅暴露模拟量/数字量接口
  实现: 通过中间 PLC (如 Beckhoff CX 系列) 桥接
        PLC 完成 A/D 转换和协议转换
  延迟: ~5-20 ms

方案 D: 串口/专有协议
  适用: 特定品牌焊机的专有通信接口
  实现: 开发专用驱动适配层
  备注: 需与焊机厂商配合
```

### 4.4 数据库设计

#### 4.4.1 时序数据库（过程信号存储）

```
选型: InfluxDB 2.x (OSS) 或 TimescaleDB (PostgreSQL 扩展)

InfluxDB 方案:
  Bucket: weld_signals
  Measurement: weld_process
  Tags:
    - equipment_id: 设备编号
    - weld_id: 焊点ID
    - channel: 信号通道名 (power, frequency, collapse, force, ...)
  Fields:
    - value: float64 信号值
  Timestamp: ns 精度

  写入性能: ~100,000 points/sec (满足 6通道 x 10kHz = 60K points/sec)
  存储策略:
    - 原始信号: 保留 7 天, 然后降采样至 1kHz 保留 90 天
    - 异常焊点原始信号: 永久保留
    - 压缩比: ~10:1 (TSM 压缩)
```

#### 4.4.2 关系型数据库（元数据与配置）

```
选型: PostgreSQL 15+

核心表设计:

Table: weld_records (焊点记录, 每焊点一行)
  weld_id         VARCHAR(32) PRIMARY KEY
  equipment_id    VARCHAR(16)
  timestamp       TIMESTAMPTZ
  batch_id        VARCHAR(32)
  product_id      VARCHAR(32)
  settings        JSONB          -- 焊接参数设定值
  features        JSONB          -- 50维特征向量
  predictions     JSONB          -- 质量预测结果
  spc_status      JSONB          -- SPC 状态
  result          VARCHAR(8)     -- PASS/FAIL/SUSPECT
  adjustments     JSONB          -- 参数调整记录

Table: quality_labels (质量标签, 抽检/全检结果)
  label_id        SERIAL PRIMARY KEY
  weld_id         VARCHAR(32) REFERENCES weld_records
  F_peel_N        FLOAT          -- 实测剥离力
  R_contact_mOhm  FLOAT          -- 实测接触电阻
  appearance      VARCHAR(16)    -- 外观等级
  failure_mode    VARCHAR(32)    -- 失效模式 (如有)
  inspector_id    VARCHAR(16)
  timestamp       TIMESTAMPTZ

Table: model_versions (模型版本管理)
  model_id        SERIAL PRIMARY KEY
  model_type      VARCHAR(32)    -- quality_predictor / anomaly_detector / ...
  version         VARCHAR(16)
  training_data   JSONB          -- 训练数据描述
  metrics         JSONB          -- 验证指标
  artifact_path   VARCHAR(256)   -- 模型文件路径
  status          VARCHAR(16)    -- active / staging / retired
  deployed_at     TIMESTAMPTZ

Table: equipment_status (设备状态)
  equipment_id    VARCHAR(16)
  timestamp       TIMESTAMPTZ
  tip_change_n    INTEGER        -- 自上次换头焊接次数
  tip_wear_index  FLOAT          -- 磨损指标
  transducer_health FLOAT        -- 换能器健康度
  last_calibration TIMESTAMPTZ
  status          VARCHAR(16)    -- normal / warning / alarm

Table: spc_control_limits (SPC 控制限)
  chart_name      VARCHAR(32)
  product_id      VARCHAR(32)
  cl              FLOAT          -- 中心线
  ucl             FLOAT          -- 上控制限
  lcl             FLOAT          -- 下控制限
  usl             FLOAT          -- 上规格限
  lsl             FLOAT          -- 下规格限
  updated_at      TIMESTAMPTZ

索引策略:
  - weld_records: (equipment_id, timestamp), (batch_id), (result)
  - quality_labels: (weld_id), (timestamp)
  - 分区策略: 按月分区 weld_records 表
```

#### 4.4.3 缓存层

```
选型: Redis 7.x

用途:
  - 当前焊接参数缓存 (最新设定值, TTL=无限)
  - 滑动窗口统计量 (SPC 计算用, 最近 500 焊点)
  - 模型推理缓存 (相似输入的预测结果, TTL=60s)
  - 实时报警状态 (当前报警级别, 未确认报警队列)
  - 设备状态快照 (磨损指标, 健康度, 焊接计数)
```

### 4.5 软件技术栈汇总

| 层级 | 组件 | 技术选型 | 理由 |
|------|------|---------|------|
| 实时采集 | DAQ 驱动 | C/C++ + EtherCAT | 确保 us 级时序精度 |
| 信号处理 | DSP 管道 | C++ / Rust | 低延迟确定性处理 |
| 特征提取 | 特征引擎 | Python (NumPy/SciPy) + Cython | 性能与开发效率平衡 |
| ML 推理 | 推理引擎 | ONNX Runtime / LightGBM C API | 跨平台, 低延迟推理 |
| 优化引擎 | 参数优化 | Python (BoTorch / scikit-optimize) | 贝叶斯优化生态成熟 |
| SPC 引擎 | 统计监控 | Python (自研) + NumPy | 定制化规则灵活性 |
| 数据管道 | 消息队列 | Apache Kafka / ZeroMQ | 可靠传输, 解耦 |
| 时序存储 | 信号存储 | InfluxDB / TimescaleDB | 高写入吞吐, 压缩好 |
| 关系存储 | 元数据 | PostgreSQL | 成熟可靠, JSONB 灵活 |
| 缓存 | 状态缓存 | Redis | 低延迟键值访问 |
| 容器化 | 部署 | Docker + K3s | 轻量容器编排 |
| 监控 | 系统监控 | Prometheus + Grafana | 工业级可观测性 |
| 前端 | HMI/Dashboard | React + ECharts | 实时可视化 |
| API | 服务接口 | FastAPI (Python) | 高性能异步 API |

---

## 5. 系统性能指标

### 5.1 延迟 KPI

| 指标 | 目标值 | 测量方法 | 验收标准 |
|------|--------|---------|---------|
| 信号采集完整性 | 丢包率 < 0.01% | 连续 24 小时压力测试 | P99 满足 |
| 特征提取延迟 | < 5 ms (P99) | 端到端计时 | 10000 焊点统计 |
| 质量预测延迟 | < 10 ms (P99) | 模型推理计时 | 10000 次推理统计 |
| 异常检测延迟 | < 5 ms (P99) | 端到端计时 | 10000 焊点统计 |
| 参数下发延迟 | < 500 ms (P99) | 指令发出到确认 | 1000 次调整统计 |
| 安全保护响应 | < 1 ms | 硬件测试 | 100% 满足 |
| 全链路延迟 (采集到参数就绪) | < 50 ms | 端到端计时 | P95 满足 |

### 5.2 质量预测精度 KPI

| 指标 | 目标值 | 基线 (无 AI) | 验收条件 |
|------|--------|-------------|---------|
| 剥离力预测 RMSE | < 3 N | -- | Test 集 >= 500 焊点 |
| 剥离力预测 R^2 | > 0.90 | -- | Test 集 >= 500 焊点 |
| 接触电阻预测 RMSE | < 0.01 mOhm | -- | Test 集 >= 500 焊点 |
| 不合格品检出率 (Recall) | > 98% | 100% (全检) | 不合格品不得漏检 |
| 误报率 (FPR) | < 5% | 0% (全检) | 减少不必要的抽检 |
| 异常检测召回率 | > 95% | 人工巡检 | 已知异常模式全覆盖 |
| 异常检测误报率 | < 2% | -- | 避免频繁停线 |

### 5.3 过程能力提升 KPI

| 指标 | 当前基线 | 目标值 | 提升幅度 |
|------|---------|--------|---------|
| 剥离力 CPK | 1.33 (手动调参) | >= 1.67 | +25% |
| 接触电阻 CPK | 1.33 | >= 1.67 | +25% |
| 焊接一次合格率 | 99.5% | >= 99.9% | -80% 不良率 |
| 参数调整响应时间 | 人工 30 min+ | 自动 < 1 s | >1800x |
| 批次切换稳定时间 | 50~100 焊点 | < 20 焊点 | >60% 缩短 |
| 焊头寿命利用率 | 70% (保守更换) | > 90% | +28% |
| 非计划停机时间 | 基线 | 减少 50% | -50% |

### 5.4 系统可靠性 KPI

| 指标 | 目标值 | 说明 |
|------|--------|------|
| 系统可用性 | >= 99.9% | 年停机 < 8.76 小时 |
| 数据完整性 | >= 99.99% | 焊点数据无丢失 |
| 模型服务可用性 | >= 99.95% | 降级方案: 回退到固定参数 |
| 安全保护可靠性 | 100% | SIL2 等级, 独立硬件通道 |
| 参数调整安全性 | 0 次越限事件/年 | 硬约束永不违反 |
| 平均故障恢复时间 (MTTR) | < 30 min | 自动故障转移 + 人工介入 |

### 5.5 业务价值 KPI

| 指标 | 计算方法 | 目标值 |
|------|---------|--------|
| 焊接不良成本降低 | (旧不良率 - 新不良率) x 单焊点成本 x 日焊接量 | >= 60% 降低 |
| 焊头更换成本节约 | (旧更换频率 - 新更换频率) x 焊头单价 | >= 20% 节约 |
| 人工调参工时节约 | 人工调参频率 x 平均调参时间 | >= 80% 节约 |
| 产能提升 | 减少的停线时间 x 产线产能 | >= 3% 提升 |
| 投资回收期 | 系统总投入 / 年节约成本 | <= 18 个月 |

---

## 附录 A: 缩略语表

| 缩略语 | 全称 | 中文含义 |
|--------|------|---------|
| CPK | Process Capability Index | 过程能力指数 |
| PPK | Process Performance Index | 过程性能指数 |
| SPC | Statistical Process Control | 统计过程控制 |
| CUSUM | Cumulative Sum | 累积和 |
| EWMA | Exponentially Weighted Moving Average | 指数加权移动平均 |
| MMD | Maximum Mean Discrepancy | 最大均值差异 |
| PLL | Phase-Locked Loop | 锁相环 |
| SHAP | SHapley Additive exPlanations | SHAP 特征解释 |
| RUL | Remaining Useful Life | 剩余使用寿命 |
| OOD | Out-of-Distribution | 分布外 |
| MES | Manufacturing Execution System | 制造执行系统 |
| HMI | Human-Machine Interface | 人机界面 |
| EI | Expected Improvement | 期望改进 |
| GP | Gaussian Process | 高斯过程 |
| IMC | Intermetallic Compound | 金属间化合物 |

---

## 附录 B: 参考文献与标准

1. IPC/JEDEC J-STD-002: 焊接性测试标准
2. ISO 14373: 电阻焊接质量要求
3. IATF 16949: 汽车行业质量管理体系
4. IEC 61508: 功能安全标准 (SIL 等级定义)
5. AWS C1.1: 电阻焊接推荐实践
6. GB/T 38058-2019: 锂离子电池安全标准
